if I18n.locale == :de
  page_title = "Zentrum fÃ¼r zeitgenÃ¶ssischen Tanz in Berlin"
else
  page_title = "Center for contemporary dance in Berlin"
end
set_meta_tags :title => page_title, :reverse => false

# get all stage events starting now
#events = Event.joins(:type, :event_details).where(
#  '(event_types.id = 1 OR event_types.id = 7 OR event_types.id = 8 OR event_types.id = 9) 
#  AND event_details.start_date >= ? AND event_details.end_date <= ?', 
#    Time.now).order('event_details.start_date ASC')


# get stage events that are not in a festival
events = Event.not_in_festival.stage_event

ul :class => "start_events_listing" do

  # pick the events that have an occurrence today
  events_today = events.select {|e| e.occurs_on? Date.today }

  # collect all the occurrences for these events and sort by time
  occurrences_today = []
  events_today.each do |e| 
    occurrences_today += (e.occurrences_on Date.today)
  end
  occurrences_today.sort_by! { |x| x[0] }

  occurrences_today[0..2].each do |o|
    li do
      span l(o[0], :format => :hours_minutes), :class => "time"
      span :class => "event" do
        a o[1].event.title, :href => event_path(o[1].event)
      end
    end
  end

  if occurrences_today.length >= 3 
    max_tomorrow = 1
  else
    max_tomorrow = 4 - occurrences_today.length
  end

  # TEMPORARY solution for featured events. TODO: sort all dates on the start page, use "feature on start page", only query future events
  featured_events = Event.where(:id => [400])
  featured_events.select{ |e| e.next_occurrence && ![Date.today, Date.tomorrow].index(e.next_occurrence.time.to_date) }.each do |e|
    li do
      span l(e.next_occurrence.time.to_date, :format => :short), :class => "time"
      span :class => "event" do
        a e.title+" "+t(:with)+" "+e.people.first.name, :href => event_path(e)
      end
    end  
  end

  # get festivals that started before today and have not ended
  festivals_today = Festival.now_and_future.includes(:event_details).select {|f| f.start_date ? (f.start_date <= Date.today && f.end_date >= Date.today) : false }

  festivals_today.each do |f|

    # check if festival actually has an occurrence today or tomorrow
    festival_event_today = false
    festival_event_tomorrow = false
    festival_event_date = nil
    f.events.each do |e|
      if e.occurs_on? Date.today
        festival_event_today = true
      elsif e.occurs_on? Date.tomorrow
        festival_event_tomorrow = true
      end
    end
    # if it doesn't, use next event start date
    unless festival_event_today or festival_event_tomorrow
      events_after_tomorrow = f.events.select {|e| e.start_date > Date.tomorrow }
      if events_after_tomorrow.size > 0
        events_after_tomorrow.sort_by! { |e| e.start_date }
        festival_event_date = events_after_tomorrow[0].start_date
      end
    end

    li do
      if festival_event_today 
        span t(:today), :class => "time"
      elsif festival_event_tomorrow  
        span t(:tomorrow), :class => "time"
      elsif festival_event_date 
        span l(festival_event_date, :format => :short), :class => "time"
      end
      if festival_event_today or festival_event_tomorrow or festival_event_date
        span :class => "event" do
          a f.name, :href => festival_path(f)
        end
      end
    end
  end

  # pick the events that have an occurrence tomorrow
  events_tomorrow = events.select {|e| e.occurs_on? Date.tomorrow }

  # collect all the occurrences for these events and sort by time
  occurrences_tomorrow = []
  events_tomorrow.each do |e| 
    occurrences_tomorrow += (e.occurrences_on Date.tomorrow)
  end
  occurrences_tomorrow.sort_by! { |x| x[0] }

  occurrences_tomorrow[0 .. (max_tomorrow - 1)].each do |o|
    li do
      span t(:tomorrow), :class => "time"
      #span o[0] # soll nicht erscheinen
      span :class => "event" do
        a o[1].event.title, :href => event_path(o[1].event)
      end
    end
  end

  # get festivals that will start tomorrow
  festivals_tomorrow = Festival.now_and_future.includes(:event_details).select {|f| f.start_date ? (f.start_date == Date.tomorrow) : false }

  festivals_tomorrow.each do |f|
    li do
      span t(:tomorrow), :class => "time"
      span :class => "event" do
        a f.name, :href => festival_path(f)
      end
    end
  end

  # get festivals that will start after tomorrow (maximum 2)
  festivals_after_tomorrow = Festival.now_and_future.includes(:event_details).select {|f| f.start_date ? (f.start_date > Date.tomorrow) : false }
  festivals_after_tomorrow.sort! { |a,b| a.start_date <=> b.start_date } # sort by start date

  festivals_after_tomorrow[0 .. 1].each do |f|
    li do
      span l(f.start_date, :format => :short), :class => "time"
      span :class => "event" do
        a f.name, :href => festival_path(f)
      end
    end
  end

  # todo: get custom notice
  custom_date = TextItem.where(:name => "start_datum").first
  custom_notice = TextItem.where(:name => "start_inhalt").first
  unless custom_date.nil? || custom_notice.nil?
    if custom_date.content && custom_notice.content
      li do
        span custom_date.content[0..5], :class => "time"
        span custom_notice.content[0..51], :class => "event"
      end
    end
  end

  # sommer spezial 2016
  if Date.today >= Date.new(2016,6,14) && Date.today <= Date.new(2016,8,19)
    li do
      span "1-19.8.", :class => "time"
      span :class => "event" do
        page = Page.all.select{ |p| p.slug == "sommer-spezial"}.first
        link_to page.title, page_path(page)
      end
    end  
  end

  # tanzen-im-hof
  if Date.today >= Date.new(2016,6,8) && Date.today <= Date.new(2016,10,1)
    li do
      # span "01."+(Date.today.day > 1 ? Date.today.month+1 : Date.today.month).to_s.rjust(2, '0')+".", :class => "time"
      span t(:new), :class => "time"
      span :class => "event" do
        page = Page.all.select{ |p| p.slug == "tanzen-im-hof"}.first
        link_to page.title, page_path(page)
      end
    end  
  end  

  # impossible forest
  page = Page.all.select{ |p| p.slug == "impossible-forest-impossible-garden"}.first
  if page
    li do
      span t(:call), :class => "time"
      span :class => "event" do
        link_to page.title[0..51], page_path(page)
      end
    end  
  end
  
end

