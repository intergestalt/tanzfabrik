if I18n.locale == :de
  page_title = "Zentrum für zeitgenössischen Tanz in Berlin"
else
  page_title = "Center for contemporary dance in Berlin"
end
set_meta_tags :title => page_title, :reverse => false

# get all stage events starting now
#events = Event.joins(:type, :event_details).where(
#  '(event_types.id = 1 OR event_types.id = 7 OR event_types.id = 8 OR event_types.id = 9) 
#  AND event_details.start_date >= ? AND event_details.end_date <= ?', 
#    Time.now).order('event_details.start_date ASC')


# get stage events that are not in a festival
events = Event.not_in_festival.stage_event


ul :class => "start_events_listing" do

  # pick the events that have an occurrence today
  events_today = events.select {|e| e.occurs_on? Date.today }

  # collect all the occurrences for these events and sort by time
  occurrences_today = []
  events_today.each do |e| 
    occurrences_today += (e.occurrences_on Date.today)
  end
  occurrences_today.sort_by! { |x| x[0] }

  occurrences_today[0..2].each do |o|
    li do
      span l(o[0], :format => :hours_minutes), :class => "time"
      span :class => "event" do
        a o[1].event.title, :href => event_path(o[1].event)
      end
    end
  end

  if occurrences_today.length >= 3 
    max_tomorrow = 1
  else
    max_tomorrow = 4 - occurrences_today.length
  end

  # get festivals that started before today and have not ended
  festivals_today = Festival.select {|f| f.start_date ? (f.start_date <= Date.today && f.end_date >= Date.today) : false }

  festivals_today.each do |f|
    li do
      span t(:today), :class => "time"
      span :class => "event" do
        a f.name, :href => festival_path(f)
      end
    end
  end

  # pick the events that have an occurrence tomorrow
  events_tomorrow = events.select {|e| e.occurs_on? Date.tomorrow }

  # collect all the occurrences for these events and sort by time
  occurrences_tomorrow = []
  events_tomorrow.each do |e| 
    occurrences_tomorrow += (e.occurrences_on Date.tomorrow)
  end
  occurrences_tomorrow.sort_by! { |x| x[0] }

  occurrences_tomorrow[0 .. (max_tomorrow - 1)].each do |o|
    li do
      span t(:tomorrow), :class => "time"
      #span o[0] # soll nicht erscheinen
      span :class => "event" do
        a o[1].event.title, :href => event_path(o[1].event)
      end
    end
  end

  # get festivals that will start tomorrow
  festivals_tomorrow = Festival.select {|f| f.start_date ? (f.start_date == Date.tomorrow) : false }

  festivals_tomorrow.each do |f|
    li do
      span t(:tomorrow), :class => "time"
      span :class => "event" do
        a f.name, :href => festival_path(f)
      end
    end
  end

  # get festivals that will start after tomorrow (maximum 2)
  festivals_after_tomorrow = Festival.select {|f| f.start_date ? (f.start_date > Date.tomorrow) : false }

  festivals_after_tomorrow[0 .. 1].each do |f|
    li do
      span l(f.start_date, :format => :short), :class => "time"
      span :class => "event" do
        a f.name, :href => festival_path(f)
      end
    end
  end

  # todo: get custom notice
  custom_date = TextItem.where(:name => "start_datum").first
  custom_notice = TextItem.where(:name => "start_inhalt").first
  unless custom_date.nil? || custom_notice.nil?
    if custom_date.content && custom_notice.content
      li do
        span custom_date.content[0..5], :class => "time"
        span custom_notice.content[0..51], :class => "event"
      end
    end
  end
  
end

