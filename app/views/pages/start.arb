if I18n.locale == :de
  page_title = "Zentrum für zeitgenössischen Tanz in Berlin"
else
  page_title = "Center for contemporary dance in Berlin"
end
set_meta_tags :title => page_title, :reverse => false

# get all stage events starting now
#events = Event.joins(:type, :event_details).where(
#  '(event_types.id = 1 OR event_types.id = 7 OR event_types.id = 8 OR event_types.id = 9) 
#  AND event_details.start_date >= ? AND event_details.end_date <= ?', 
#    Time.now).order('event_details.start_date ASC')


# get stage events that are not in a festival
events = Event.not_in_festival.stage_event

ul do

  # pick the events that have an occurrence today
  events_today = events.select {|e| e.occurs_on? Date.today }

  # collect all the occurrences for these events and sort by time
  occurrences_today = []
  events_today.each do |e| 
    occurrences_today += (e.occurrences_on Date.today)
  end
  occurrences_today.sort_by! { |x| x[0] }

  occurrences_today[0..2].each do |o|
    li do
      span l(o[0], :format => :hours_minutes), :class => "clock"
      span o[1].event.title
    end
  end

  if occurrences_today.length >= 3 
    max_tomorrow = 1
  else
    max_tomorrow = 4 - occurrences_today.length
  end

  # get festivals that started before today and have not ended
  festivals_today = Festival.select {|f| f.start_date ? (f.start_date <= Date.today && f.end_date >= Date.today) : false }

  festivals_today.each do |f|
    li do
      span "Heute: " + f.name + " (" + f.start_date.to_s + " - " + f.end_date.to_s + ")"
    end
  end

  # pick the events that have an occurrence tomorrow
  events_tomorrow = events.select {|e| e.occurs_on? Date.tomorrow }

  # collect all the occurrences for these events and sort by time
  occurrences_tomorrow = []
  events_today.each do |e| 
    occurrences_tomorrow += (e.occurrences_on Date.tomorrow)
  end
  occurrences_tomorrow.sort_by! { |x| x[0] }

  occurrences_tomorrow[0 .. (max_tomorrow - 1)].each do |o|
    li do
      span "Morgen: "
      #span o[0] # soll nicht erscheinen
      span o[1].event.title
    end
  end

  # get festivals that will start tomorrow
  festivals_tomorrow = Festival.select {|f| f.start_date ? (f.start_date == Date.tomorrow) : false }

  festivals_tomorrow.each do |f|
    li do
      span "Morgen: " + f.name + " (" + f.start_date.to_s + " - " + f.end_date.to_s + ")"
    end
  end

  # get festivals that will start after tomorrow (maximum 2)
  festivals_after_tomorrow = Festival.select {|f| f.start_date ? (f.start_date > Date.tomorrow) : false }

  festivals_after_tomorrow[0 .. 1].each do |f|
    li do
      span f.start_date.to_s + " " + f.name + " (" + f.start_date.to_s + " - " + f.end_date.to_s + ")"
    end
  end

  # todo: get custom notice
  custom_date = TextItem.where(:name => "start_datum").first
  custom_notice = TextItem.where(:name => "start_inhalt").first
  if custom_date || custom_notice
    li do
      span custom_date.content[0..5]
      span custom_notice.content[0..51]
    end
  end
  
end

